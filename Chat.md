# Chat



## 客户端传包

![image-20250401183639009](D:/Code/TYPORA/Note/Chat.assets/image-20250401183639009.png)

## 什么是大端，什么是小端

低字节：数值的**低位部分**（Least Significant Byte, LSB），即对数值大小影响最小的字节。

以	0x12345678 为例    

​	0x12 是高字节

​	0x78 是低字节

低地址：内存中某个存储单元（如变量、数组）的**起始位置**，或地址较小的位置。

#### **小端模式（Little-Endian）**

- **规则**：**低字节**存储在**低地址**，**高字节**存储在**高地址**。

#### **大端模式（Big-Endian）**

- **规则**：**高字节**存储在**低地址**，**低字节**存储在**高地址**。

## 为什么喜欢用队列去处理异步？

因为队列可以保证异步的有序性

## **rpc和grpc**

**RPC（Remote Procedure Call，远程过程调用）是一种通信协议**，允许程序像调用本地函数一样调用远程服务器上的函数或方法。它抽象了网络通信的复杂性，使得开发者无需直接处理数据传输、序列化或网络协议细节，只需关注业务逻辑。RPC的核心思想是让跨进程或跨网络的函数调用对开发者透明，常见实现方式包括基于TCP、HTTP等协议，适用于微服务架构、分布式系统等场景，例如服务A调用服务B提供的接口。典型的RPC框架（如Dubbo、Thrift）会封装通信过程，提供序列化、服务发现、负载均衡等功能，但不同框架在性能、跨语言支持和协议设计上各有侧重。

**gRPC是Google基于RPC理念开发的高性能开源框架**，默认采用HTTP/2协议实现双向流式通信，并依赖Protocol Buffers（Protobuf）作为接口定义语言（IDL）和序列化工具。与传统RPC框架相比，gRPC通过HTTP/2的多路复用、头部压缩等特性显著提升传输效率，同时Protobuf的二进制编码比JSON/XML更紧凑高效，适合高并发、低延迟场景。此外，gRPC支持跨语言开发（如C++、Java、Python、Go等），通过预编译Protobuf文件自动生成客户端和服务端代码，简化了多语言协作的复杂性。其核心能力还包括双向流式调用（如客户端流、服务端流、双向流），适用于实时通信、IoT设备控制等场景，已成为云原生和微服务领域的主流通信方案之一。

gRPC 的完整流程可以概括为以下几个阶段，涵盖从接口定义到实际通信的全过程：

------

### **1. 定义服务接口（Proto 文件）**

- **作用**：使用 Protocol Buffers（Protobuf）编写 `.proto` 文件，明确服务的方法、请求和响应消息格式。

  ```protobuf
  syntax = "proto3";
  service MyService {
    rpc GetData (Request) returns (Response) {}  // 定义 RPC 方法
  }
  message Request { string query = 1; }          // 请求结构
  message Response { string result = 1; }       // 响应结构
  ```

- **意义**：该文件是跨语言协作的契约，也是生成代码的输入。

------

### **2. 生成桩代码（Stub Code）**

- **工具**：通过 `protoc` 编译器配合 `grpc_cpp_plugin`（或其他语言插件）生成代码。

  生成文件

  - **消息类**（如 `Request.pb.h`）：序列化请求/响应消息的代码。
  - **服务类**（如 `MyService.grpc.pb.h`）：包含服务端基类（`Service`）和客户端桩（`Stub`）。

  命令示例

  ```bash
  protoc --grpc_out=. --cpp_out=. --plugin=protoc-gen-grpc=grpc_cpp_plugin my_service.proto
  ```

------

### **3. 实现服务端**

- 步骤

  1. **继承生成的服务基类**：重写定义的 RPC 方法（如 `GetData`），填充业务逻辑。
  2. **启动服务**：绑定端口，注册服务实例，监听客户端请求。

- 代码要点

  ```cpp
  class MyServiceImpl final : public MyService::Service {
    Status GetData(ServerContext* context, const Request* req, Response* res) override {
      res->set_result("Processed: " + req->query());  // 处理请求
      return Status::OK;
    }
  };
  // 启动服务器
  ServerBuilder builder;
  builder.AddListeningPort("0.0.0.0:50051", grpc::InsecureServerCredentials());
  builder.RegisterService(&service);
  std::unique_ptr<Server> server(builder.BuildAndStart());
  ```

------

### **4. 实现客户端**

1. **创建通道（Channel）**：指定服务端地址（如 `localhost:50051`）。
2. **调用桩方法**：通过生成的 `Stub` 对象发起 RPC 调用，处理响应或错误。

- 代码要点

  ```cpp
  auto channel = grpc::CreateChannel("localhost:50051", grpc::InsecureChannelCredentials());
  MyService::Stub stub(channel);
  Request request;
  request.set_query("test");
  Response response;
  ClientContext context;
  Status status = stub.GetData(&context, request, &response);
  if (status.ok()) {
    std::cout << response.result();  // 输出结果
  }
  ```

------

### **5. 通信过程（基于 HTTP/2）**

1. **建立连接**：客户端与服务端通过 TCP 建立 HTTP/2 连接。

2. **多路复用**：单个连接上并行处理多个请求/响应（减少连接开销）。

3. 传输数据

   - 客户端将 `Request` 序列化为二进制 Protobuf 数据，通过 HTTP/2 流发送。
   - 服务端反序列化数据，执行对应方法，返回序列化后的 `Response`。

4. 流式支持

   （可选）：

   - **单向流**：客户端或服务端分多次发送数据（如实时日志传输）。
   - **双向流**：双方同时通过流发送数据（如聊天应用）。

------

### **6. 关键流程总结**

1. **定义接口** → **生成代码** → **实现服务端逻辑** → **客户端调用**。
2. **底层依赖**：HTTP/2 提供高效传输，Protobuf 保证紧凑的序列化。
3. **核心优势**：跨语言、高性能、支持复杂通信模式（如流式）。

------

### **示例类比（简化版）**

想象客户端像“寄信”：

1. **写请求**（序列化）：将数据按 Protobuf 格式打包。
2. **找邮局**（创建通道）：连接到服务端地址。
3. **投递**（调用 Stub）：通过 HTTP/2 “快递”发送请求。
4. **处理信件**：服务端拆包、处理、返回结果。
5. **收件**（反序列化）：客户端解析响应数据。

## RedisMgr

实现**线程安全的Redis连接池**，支持连接复用、自动心跳检测、断线重连和密码认证，通过条件变量实现连接等待机制，降低频繁创建连接的开销。

封装**易用的Redis操作接口**（GET/SET/LPOP/HSET等），支持二进制数据操作，隐藏底层连接获取/释放细节，业务层无需感知连接池存在。

设计**连接健康检查线程**，每60秒遍历连接池发送PING命令，异常连接自动重建并重新认证，保障连接池100%可用性。

采用**单例模式+智能指针**管理全局唯一连接池，通过`std::enable_shared_from_this`确保线程安全访问，避免资源泄露。



## ChatServer

### CSession流程

**启动会话**

- 调用 Start() 后，进入 AsyncReadHead 开始接收数据。

**读取消息头**

- 通过异步读取，将固定长度的头部数据读入 _data，再复制到 _recv_head_node 中。
- 从头部解析出消息的 ID 和消息体长度，并进行合法性检查。
- 创建接收消息体的 RecvNode 对象。

**读取消息体**

- 根据消息体长度调用 AsyncReadBody，异步读取完整的消息体数据。
- 读取完成后，将数据复制到 RecvNode 中，并通过逻辑系统的消息队列传递给业务处理模块。
- 循环：继续调用 AsyncReadHead 监听下一个消息头。

**发送消息**

- 通过 Send() 函数入队待发送的消息，如果队列为空，则启动异步写操作。
- 异步写操作完成后由 HandleWrite 回调继续处理队列中剩余的消息。







## 面试题

#### 1 如何利用asio实现的tcp服务

利用asio 的多线程模式，根据cpu核数封装iocontext连接池，每个连接池跑在独立线程，采用异步`async_read`和`assync_write`方式读写，通过消息回调完成数据收发。整个项目采用的网络模式是Proactor模式，每个连接通过Session类管理，通过智能指针管理Session,b保证回调之前Session可用，底层绑定用户id和session关联，回调函数可根据session反向查找用户进行消息推送。客户端和服务器通信采用json, 通过tlv方式(消息头(`消息id+消息长度`)+消息内容)封装消息包防止粘包。通过心跳机制检测连接可用性。

#### 2 如何保证服务高可用

1. 故障检测与自动恢复
   - 实施监控系统，实时检测服务的健康状况。
   - 配置自动重启或故障转移机制，确保在故障发生时能够迅速恢复服务。
2. 分布式架构
   - 采用微服务架构，将应用拆分为多个独立的服务，降低单个服务故障对整体系统的影响。
3. 数据备份与恢复
   - 定期备份数据，并进行恢复演练，确保在数据丢失或损坏时能够快速恢复。
4. 多活部署
   - 在不同地理位置部署多个活跃的数据中心，确保在某个数据中心发生故障时，其他数据中心可以继续提供服务。

#### 3 为何封装Mysql连接池

 首先多个线程使用同一个mysql连接是不安全的，所以要为每个线程分配独立连接，而连接数不能随着线程数无线增加，所以考虑连接池，每个线程想要操作mysql的时候从连接池取出连接进行数据访问。

Mysql连接池封装包括Mgr管理层和Dao数据访问层，Mgr管理层是单例模式，Dao层包含了一个连接池，采用生产者消费者模式管理可用连接，并且通过心跳定时访问mysql保活连接。

#### 4 如何测试性能

 测试性能分为三个方面：

- 压力测试，测试服务器连接上限
- 测试一定连接数下，收发效率稳定性
- 采用pingpong协议，收发效率稳定在10ms下，连接数上限

压力测试，看服务器性能，客户端初始多个线程定时间隔连接，单服务节点连接上限2w以上稳定连接，并未出现掉线情况

测试稳定性，单服务节点连接数1W情况下，收发稳定未出现丢包和断线，并且延迟稳定在10ms

保证10ms延迟情况下，增加连接数，测下连接数上限，这个看机器性能，8000~2W连接不等。

#### 5 用到哪些设计模式和思想

- Acto模式，逻辑解耦
- 生产者消费者模式（涉及线程池）
- 单例模式(网络管理和数据库管理类)
- RAII思想(defer 回收连接)
- 代理模式(数据库，redis等通过代理对接应用层调用，底层线程池隐藏技术细节)
- MVC控制思想，客户端通过MVC三层结构设计
- 线程分离，网络线程，数据处理线程，以及UI渲染线程分离
- 心跳服务
- 数据序列化压缩发送(Protobuf，Json)
- 队列解耦合，服务器采用发送队列保证异步顺序，通过接受队列缓存收到数据，通过逻辑队列处理数据。
- 分布式设计，多服务通过grpc通信，支持断线重连
- C++11 现代化技术，智能指针，伪闭包，模板类型推导，线程池，future, promise等

#### 6 描述线程池封装

 描述线程池封装，线程池采用C++ 11 风格编写，整体来说线程池通过单例封装，内部初始化N个线程，采用生产者消费者方式管理线程，包含任务队列，任务队列采用package_task打包存储，提供对外接口commit提交任务，采用bind语法实现任务提交在commit内部自行绑定，通过智能指针伪闭包方式保证任务生命周期。同时使用C++ 11 future特性，允许外部等待任务执行完成。

#### 7 为什么要设计心跳？

在网络情况下，会出现各种各样的中断，有些是网络不稳定或者客户端主动断开连接，这种服务器是可以检测到的。

PC拔掉网线，还有一种情况客户端突然崩溃，有时候服务器会检测不到断开连接，那么你这个用户就相当于僵尸连接。

当服务器有太多僵尸连接就会造成服务器性能的损耗。

另外心跳还有一个作用，保证连接持续可用，比如mysql，redis这种连接池，如果不设计心跳，

时间过长没有访问的时候连接会自动断开。