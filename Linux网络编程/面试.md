##  五种IO模型

从TCP发送数据的流程说起

要深入的理解各种IO模型，那么必须先了解下产生各种IO的原因是什么，要知道这其中的本质问题那么我们就必须要知一条消息是如何从过一个人发送到另外一个人的；

以两个应用程序通讯为例，我们来了解一下当“A”向"B" 发送一条消息，简单来说会经过如下流程：

- 第一步：应用A把消息发送到 TCP发送缓冲区。
- 第二步： TCP发送缓冲区再把消息发送出去，经过网络传递后，消息会发送到B服务器得TCP接收缓冲区。
- 第三步：B再从TCP接收缓冲区去读取属于自己的数据。

![img](%E9%9D%A2%E8%AF%95.assets/10d1c56168effcaa9e5fb5c4ef2b7d4b.png)



![img](%E9%9D%A2%E8%AF%95.assets/4cb0ec441a50ef017fa299b0ba97aabc.png)



### IO阻塞

```
所谓阻塞IO就是当应用B发起读取数据申请时，在内核数据没有准备好之前，应用B会一直处于等待数据状态，直到内核把数据准备好了交给应用B才结束。
```

> 定义：在应用调用recvfrom读取数据时，其系统调用知道数据包到达切被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的成为阻塞IO；

流程：

- 1、应用进程向内核发起recfrom读取数据。
- 2、准备数据报（应用进程阻塞）。
- 3、将数据从内核负责到应用空间。
- 4、复制完成后，返回成功提示。

![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/7e74d75add43123a8e1a1b785d40c411.png)



### 非IO阻塞

按照上面的思路，所谓非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待。

定义

- 非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个`EWOULDBLOCK错误`，不会让应用一直等待中。
- 在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用recvfrom请求，直到读取到它数据要的数据为止。

流程：

- 1、应用进程向内核发起recvfrom读取数据。
- 2、没有数据报准备好，即刻返回EWOULDBLOCK错误码。
- 3、应用进程向内核发起recvfrom读取数据。
- 4、已有数据包准备好就进行一下 步骤，否则还是返回错误码。
- 5、将数据从内核拷贝到用户空间。
- 6、完成后，返回成功提示。
  ![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/d7365dc60d74042477500380ed2a005e.png)

### 多路复用IO(IO multiplexing)

思考一个问题：

我们还是把视角放到应用B从TCP缓冲区中读取数据这个环节来。如果在并发的环境下，可能会N个人向应用B发送消息，这种情况下我们的应用就必须创建多个线程去读取数据，每个线程都会自己调用recvfrom 去读取数据。那么此时情况可能如下图：
![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/2a64be4c1cde95034da763da30ae737f.png)
如上图一样，并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送recvfrom 请求来读取数据；

那么问题来了，这么多的线程不断调用recvfrom 请求数据，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其它事情的线程就会少。

所以，有人就提出了一个思路，能不能提供一种方式，**可以由一个线程监控多个网络请求（`我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识）`，这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。**
![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/2fbb3402589b93444bebe10c0ed9220f.png)
正如上图，IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据。

定义

**进程通过将一个或多个fd传递给select（或者其他IO复用API），阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。**
![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/4dec777283872d03134aeb46c568e427.png)

总结：
**复用IO的基本思路就是通过slect或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。**

### 信号驱动IO(signal driven IO)

复用IO模型解决了一个线程可以监控多个fd的问题，但是select是采用轮询的方式来监控多个fd的，通过不断的轮询fd的可读状态来知道是否就可读的数据，而无脑的轮询就显得有点暴力，因为大部分情况下的轮询都是无效的，所以有人就想，能不能不要我总是去问你是否数据准备就绪，能不能我发出请求后等你数据准备好了就通知我，所以就衍生了信号驱动IO模型。

于是信号驱动IO不是用循环请求询问的方式去监控数据就绪状态，具体如下：

- 1、调用`sigaction`时候建立一个`SIGIO`的信号联系，

- 2、当内核数据准备好之后再`通过SIGIO信号通知线程数据准备好后的可读状态`，

- 3、当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞

- 4、所以这样的方式下，一个应用线程也可以同时监控多个fd。

  

  ![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/4adca592f1c87e560e7190892d5232e4.png)
  定义
  首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知映应用线程调用recvfrom来读取数据。
  ![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/b6469d7da6f814ce7733a664614ba4c2.png)

  总结：

  ​		IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。

### 异步IO( asynchronous IO)

通过观察我们发现，不管是IO复用还是信号驱动，我们要读取一个数据总是要发起两阶段的请求，第一次发送select请求，询问数据状态是否准备好，第二次发送recevform请求读取数据。（这也就是为什么上面四种都是`同步IO`）

- 在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中**都需要自己参与**，那么这种我们称为`同步`；
- 如果应用发送完指令后就不再参与过程了，**只需要等待最终完成结果的通知**，那么这就属于`异步`。

思考一个问题：

也许你一开始就有一个疑问，为什么我们明明是想读取数据，什么非得要先发起一个select询问数据状态的请求，然后再发起真正的读取数据请求,能不能有一种一劳永逸的方式，`我只要发送一个请求我告诉内核我要读取数据，然后我就什么都不管了，然后内核去帮我去完成剩下的所有事情？`

有人设计了一种方案，应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，`内核会主动把数据从内核复制到用户空间`，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种一劳永逸的模式为`异步IO模型`。
![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/75faa67cebb304cf6ebc36f05b706293.png)
定义
应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。
![在这里插入图片描述](%E9%9D%A2%E8%AF%95.assets/2c472ed2bfcbe4e5a7f834737c142b3b.png)
总结：
异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。